// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: authorization_codes.sql

package gen

import (
	"context"
	"database/sql"
	"time"
)

const createAuthorizationCode = `-- name: CreateAuthorizationCode :exec
INSERT INTO authorization_codes (
    id,
    user_id,
    client_id,
    code_hash,
    redirect_uri,
    scopes,
    session_id,
    amr,
    code_challenge,
    code_challenge_method,
    mfa_session_id,
    expires_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateAuthorizationCodeParams struct {
	ID                  string
	UserID              string
	ClientID            string
	CodeHash            string
	RedirectUri         string
	Scopes              string
	SessionID           string
	Amr                 string
	CodeChallenge       string
	CodeChallengeMethod string
	MfaSessionID        sql.NullString
	ExpiresAt           time.Time
}

// Store an issued authorization code (code_hash is a deterministic fingerprint).
func (q *Queries) CreateAuthorizationCode(ctx context.Context, arg CreateAuthorizationCodeParams) error {
	_, err := q.db.ExecContext(ctx, createAuthorizationCode,
		arg.ID,
		arg.UserID,
		arg.ClientID,
		arg.CodeHash,
		arg.RedirectUri,
		arg.Scopes,
		arg.SessionID,
		arg.Amr,
		arg.CodeChallenge,
		arg.CodeChallengeMethod,
		arg.MfaSessionID,
		arg.ExpiresAt,
	)
	return err
}

const deleteExpiredAuthorizationCodes = `-- name: DeleteExpiredAuthorizationCodes :exec
DELETE FROM authorization_codes
WHERE expires_at <= CURRENT_TIMESTAMP
   OR used_at IS NOT NULL
`

// Housekeeping: remove expired or used authorization codes.
func (q *Queries) DeleteExpiredAuthorizationCodes(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredAuthorizationCodes)
	return err
}

const getAuthorizationCodeByHash = `-- name: GetAuthorizationCodeByHash :one
SELECT
    id,
    user_id,
    client_id,
    code_hash,
    redirect_uri,
    scopes,
    session_id,
    amr,
    code_challenge,
    code_challenge_method,
    mfa_session_id,
    expires_at,
    used_at,
    created_at
FROM authorization_codes
WHERE code_hash = ?
  AND used_at IS NULL
  AND expires_at > CURRENT_TIMESTAMP
LIMIT 1
`

// Lookup an authorization code for redemption if still valid.
func (q *Queries) GetAuthorizationCodeByHash(ctx context.Context, codeHash string) (AuthorizationCode, error) {
	row := q.db.QueryRowContext(ctx, getAuthorizationCodeByHash, codeHash)
	var i AuthorizationCode
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ClientID,
		&i.CodeHash,
		&i.RedirectUri,
		&i.Scopes,
		&i.SessionID,
		&i.Amr,
		&i.CodeChallenge,
		&i.CodeChallengeMethod,
		&i.MfaSessionID,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const markAuthorizationCodeUsed = `-- name: MarkAuthorizationCodeUsed :exec
UPDATE authorization_codes
SET used_at = CURRENT_TIMESTAMP
WHERE id = ?
  AND used_at IS NULL
`

// Mark an authorization code as consumed.
func (q *Queries) MarkAuthorizationCodeUsed(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, markAuthorizationCodeUsed, id)
	return err
}
