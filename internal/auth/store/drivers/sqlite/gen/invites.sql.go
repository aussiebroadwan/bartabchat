// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: invites.sql

package gen

import (
	"context"
	"database/sql"
	"time"
)

const createInvite = `-- name: CreateInvite :exec
INSERT INTO invites (id, token_hash, client_id, created_by, role_id, expires_at, reusable)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateInviteParams struct {
	ID        string
	TokenHash string
	ClientID  string
	CreatedBy string
	RoleID    string
	ExpiresAt time.Time
	Reusable  bool
}

// Mint a new invite (token is stored as SHA-256 fingerprint).
func (q *Queries) CreateInvite(ctx context.Context, arg CreateInviteParams) error {
	_, err := q.db.ExecContext(ctx, createInvite,
		arg.ID,
		arg.TokenHash,
		arg.ClientID,
		arg.CreatedBy,
		arg.RoleID,
		arg.ExpiresAt,
		arg.Reusable,
	)
	return err
}

const deleteExpiredInvites = `-- name: DeleteExpiredInvites :exec
DELETE FROM invites
WHERE expires_at <= CURRENT_TIMESTAMP
`

// Housekeeping: delete expired invites (optional cleanup).
func (q *Queries) DeleteExpiredInvites(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredInvites)
	return err
}

const getActiveInviteByTokenHash = `-- name: GetActiveInviteByTokenHash :one
SELECT id, token_hash, client_id, created_by, role_id, expires_at, reusable, used, used_by, created_at, updated_at
FROM invites
WHERE token_hash = ?
  AND used = 0
  AND expires_at > CURRENT_TIMESTAMP
LIMIT 1
`

// Lookup invite for redemption:
//   - matches token hash
//   - not used
//   - not expired
func (q *Queries) GetActiveInviteByTokenHash(ctx context.Context, tokenHash string) (Invite, error) {
	row := q.db.QueryRowContext(ctx, getActiveInviteByTokenHash, tokenHash)
	var i Invite
	err := row.Scan(
		&i.ID,
		&i.TokenHash,
		&i.ClientID,
		&i.CreatedBy,
		&i.RoleID,
		&i.ExpiresAt,
		&i.Reusable,
		&i.Used,
		&i.UsedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const markInviteUsed = `-- name: MarkInviteUsed :exec
UPDATE invites
SET used = 1,
    used_by = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
  AND used = 0
`

type MarkInviteUsedParams struct {
	UsedBy sql.NullString
	ID     string
}

// Mark invite used by a specific user.
func (q *Queries) MarkInviteUsed(ctx context.Context, arg MarkInviteUsedParams) error {
	_, err := q.db.ExecContext(ctx, markInviteUsed, arg.UsedBy, arg.ID)
	return err
}
